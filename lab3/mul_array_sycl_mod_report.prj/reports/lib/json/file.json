[{"path":"/home/clinux01/eci35_hetprog/lab3/mul_array_sycl_mod.cc", "name":"mul_array_sycl_mod.cc", "has_active_debug_locs":false, "absName":"/home/clinux01/eci35_hetprog/lab3/mul_array_sycl_mod.cc", "content":"#include <iostream>\u000A#include <random>\u000A#include <vector>\u000A#include <unistd.h>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Ausing namespace sycl;\u000A\u000Anamespace {\u000A  constexpr int M = 1<<3;\u000A};\u000A\u000Aclass naive;\u000A\u000Aint main() {\u000A    std::vector<float> A, res(1);\u000A\u000A    volatile size_t n = 1024 + sleep(0);\u000A\u000A    A.reserve(n);\u000A\u000A    std::random_device rd;\u000A    std::mt19937 gen(rd());\u000A    std::uniform_real_distribution<float> dis(0.0f, 0.25f);\u000A\u000A    float value = dis(gen);\u000A    A.push_back(value);\u000A\u000A    for(size_t i = 1; i <= n; ++i) {\u000A      A.push_back(A[0] + static_cast<float>(i)/static_cast<float>(n));\u000A    }\u000A\u000A    sycl::cpu_selector device_selector;\u000A    sycl::queue q(device_selector);\u000A\u000A    {\u000A      buffer buf_A {A};\u000A      buffer buf_res {res};\u000A      q.submit([&](handler &h) {\u000A          auto A_ps = buf_A.get_access(h, read_only);\u000A          auto res_ps = buf_res.get_access(h, write_only);\u000A          h.single_task<class naive>([=]() {\u000A            float acc[M];\u000A\u000A            #pragma unroll\u000A            for (auto i = 0; i < M; i++)\u000A              acc[i] = 1.0;\u000A\u000A#if 0\u000A            #pragma unroll (M)\u000A            for (auto i = 0; i < n; i++)\u000A                acc[i & (M-1)] *= A_ps[i];\u000A#else\u000A            #pragma ivdep\u000A            for (auto i = 0; i < n; i += M)\u000A              #pragma unroll\u000A              #pragma ivdep\u000A              for (auto j = 0; j < M; j++)\u000A                acc[j] *= A_ps[i+j];\u000A#endif\u000A\u000A            res_ps[0] = 1.0;\u000A            #pragma unroll\u000A            for (auto i = 0; i < M; i++)\u000A              res_ps[0] *= acc[i];\u000A          });\u000A      });\u000A    }\u000A\u000A    std::cout << \"A[0] = \" << A[0] << std::endl;\u000A    std::cout << \"A[1] = \" << A[1] << std::endl;\u000A    std::cout << \"A[2] = \" << A[2] << std::endl;\u000A    std::cout << \"res[0] = \" << res[0] << std::endl;\u000A}\u000A"}, {"path":"/media/libre/oneapi/tbb/2021.6.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/media/libre/oneapi/tbb/2021.6.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}]